apiVersion: v1
kind: ConfigMap
metadata:
  namespace: '{{ .Values.metadata.namespace }}'
  name: '{{ .Values.metadata.configmap_name }}'
  labels:
    app: '{{ .Values.metadata.deployment_name }}'
data:
  # -- General --
  # Information regarding which AnyLog node configurations to enable. By default, even if everything is disabled, AnyLog starts TCP and REST connection protocols
  NODE_TYPE: '{{ .Values.general.NODE_TYPE }}'
  # Name of the AnyLog instance
  NODE_NAME: '{{ .Values.general.NODE_NAME }}'
  # Owner of the AnyLog instance
  COMPANY_NAME: '{{ .Values.general.COMPANY_NAME }}'
  # Coordinates of the machine - used by Grafana to map the network
  {{ if ne .Values.general.LOCATION "" }} 
  LOCATION: '{{ .Values.general.LOCATION }}'
  {{ end }}
  # Country where machine is located
  {{ if ne .Values.general.COUNTRY "" }}
  COUNTRY: '{{ .Values.general.COUNTRY }}'
  {{ end }} 
  # State where machine is located
  {{ if ne .Values.general.STATE "" }}
  STATE: '{{ .Values.general.STATE }}'
  {{ end }} 
  # City where machine is located
  {{ if ne .Values.general.CITY "" }}
  CITY: '{{ .Values.general.CITY }}'
  {{ end }} 

  # -- Networking --
  # Connect to TCP, REST and Message Broker (if configured) based on correlating node policy
  POLICY_BASED_NETWORKING: '{{ .Values.networking.POLICY_BASED_NETWORKING }}'
  # whether to setup networking based on a (generic) configuration policy - good for both REST and other nodes
  CONFIG_POLICY: '{{ .Values.networking.CONFIG_POLICY }}'
  # Declare Policy name
  CONFIG_POLICY_NAME: '{{ .Values.networking.CONFIG_POLICY_NAME }}'
  KUBERNETES_SERVICE_IP: '{{ .Values.networking.KUBERNETES_SERVICE_IP }}'
  # External IP address of the machine
  {{ if ne .Values.networking.EXTERNAL_IP "" }}
  EXTERNAL_IP: '{{ .Values.networking.EXTERNAL_IP }}'
  {{ end }}
  # Local or  internal network IP address of the machine
  {{ if ne .Values.networking.LOCAL_IP "" }}
  LOCAL_IP: '{{ .Values.networking.LOCAL_IP }}'
  {{ end }}

  # Overlay IP address - if set, will replace local IP address when connecting to network
  {{ if ne .Values.networking.OVERLAY_IP "" }}
  OVERLAY_IP: '{{ .Values.networking.OVERLAY_IP }}'
  {{ end }}
  # Configurable (local) IP address that can be used when behind a proxy, or using Kubernetes for static IP
  {{ if ne .Values.networking.PROXY_IP "" }}
  PROXY_IP: '{{ .Values.networking.PROXY_IP }}'
  {{ end }}

  # Port address used by AnyLog's TCP protocol to communicate with other nodes in the network
  ANYLOG_SERVER_PORT: '{{ .Values.networking.ANYLOG_SERVER_PORT }}'
  # A bool value that determines if to bind to a specific IP and Port (a false value binds to all IPs)
  TCP_BIND: '{{ .Values.networking.TCP_BIND }}'
  # The number of concurrent threads supporting HTTP requests.
  TCP_THREADS: '{{ .Values.networking.TCP_THREADS }}'

  # Port address used by AnyLog's REST protocol
  ANYLOG_REST_PORT: '{{ .Values.networking.ANYLOG_REST_PORT }}'
  # A bool value that determines if to bind to a specific IP and Port (a false value binds to all IPs)
  REST_BIND: '{{ .Values.networking.REST_BIND }}'
  # Timeout in seconds to determine a time interval such that if no response is being returned during the time interval, the system returns timeout error.
  REST_TIMEOUT: '{{ .Values.networking.REST_TIMEOUT }}'
  # Number of REST threads
  REST_THREADS: '{{ .Values.networking.REST_THREADS }}'
  # Boolean value to determine if messages are send over HTTPS with client certificates.
  REST_SSL: '{{ .Values.networking.REST_SSL }}'

  {{- if .Values.networking.ANYLOG_BROKER_PORT }}
  # Port value to be used as an MQTT broker, or some other third-party broker
  ANYLOG_BROKER_PORT: '{{ .Values.networking.ANYLOG_BROKER_PORT }}'
  # A bool value that determines if to bind to a specific IP and Port (a false value binds to all IPs)
  BROKER_BIND: '{{ .Values.networking.BROKER_BIND }}'
  # The number of concurrent threads supporting broker requests.
  BROKER_THREADS: '{{ .Values.networking.BROKER_THREADS }}'
  {{ end }}


  # -- Database --
  # --> SQL
  # Physical database type
  DB_TYPE: '{{ .Values.database.DB_TYPE }}'
  # Username for SQL database connection
  DB_USER: '{{ .Values.database.DB_USER }}'
  # Password correlated to database user
  DB_PASSWD: '{{ .Values.database.DB_PASSWD }}'
  # Database IP address
  DB_IP: '{{ .Values.database.DB_IP }}'
  # Database port number
  DB_PORT: '{{ .Values.database.DB_PORT }}'
  # Whether to set autocommit data
  AUTOCOMMIT: '{{ .Values.database.AUTOCOMMIT }}'
  # Whether to start to start system_query logical database
  SYSTEM_QUERY: '{{ .Values.database.SYSTEM_QUERY }}'
  # Run system_query using in-memory SQLite. If set to false, will use pre-set database type
  MEMORY: '{{ .Values.database.MEMORY }}'
  # --> NoSQL
  # Whether to enable NoSQL logical database
  NOSQL_ENABLE: '{{ .Values.database.NOSQL_ENABLE }}'
  # Physical database type
  NOSQL_TYPE: '{{ .Values.database.NOSQL_TYPE }}'
  # Username for SQL database connection
  NOSQL_USER: '{{ .Values.database.NOSQL_USER }}'
  # Password correlated to database user
  NOSQL_PASSWD: '{{ .Values.database.NOSQL_PASSWD }}'
  # Database IP address
  NOSQL_IP: '{{ .Values.database.NOSQL_IP }}'
  # Database port number
  NOSQL_PORT: '{{ .Values.database.NOSQL_PORT }}'
  # Store blobs in database
  NOSQL_BLOBS_DMBS: '{{ .Values.database.NOSQL_BLOBS_DMBS }}'
  # Store blobs in folder
  NOSQL_BLOBS_FOLDER: '{{ .Values.database.NOSQL_BLOBS_FOLDER }}'
  # Compress stored blobs
  NOSQL_BLOBS_COMPRESS: '{{ .Values.database.NOSQL_BLOBS_COMPRESS }}'
  # Whether (re)store a blob if already exists
  NOSQL_BLOBS_REUSE: '{{ .Values.database.NOSQL_BLOBS_REUSE }}'

  #-- BLOCKCHAIN --
  # TCP connection information for Master Node
  LEDGER_CONN: '{{ .Values.blockchain.LEDGER_CONN }}'
  # How often to sync from blockchain
  SYNC_TIME: '{{ .Values.blockchain.SYNC_TIME }}'
  # Source of where the data is coming from
  BLOCKCHAIN_SOURCE: '{{ .Values.blockchain.BLOCKCHAIN_SOURCE }}'
  # Where will the copy of the blockchain be stored
  BLOCKCHAIN_DESTINATION: '{{ .Values.blockchain.BLOCKCHAIN_DESTINATION }}'

  #-- Operator --
  # Operator ID
  MEMBER: '{{ .Values.operator.Member }}'
  # Owner of the cluster
  CLUSTER_NAME: '{{ .Values.operator.CLUSTER_NAME }}'
  # Logical database name
  DEFAULT_DBMS: '{{ .Values.operator.DEFAULT_DBMS }}'
  # Whether of not to enable HA against the cluster
  ENABLE_HA: '{{ .Values.operator.ENABLE_HA }}'
  # How many days back to sync between nodes
  START_DATE: '{{ .Values.operator.START_DATE }}'
  # Whether to enable partitioning
  ENABLE_PARTITIONS: '{{ .Values.operator.ENABLE_PARTITIONS }}'
  # Which tables to partition
  TABLE_NAME: '{{ .Values.operator.TABLE_NAME }}'
  PARTITION_COLUMN: '{{ .Values.operator.PARTITION_COLUMN }}'
  # Time period to partition by
  PARTITION_INTERVAL: '{{ .Values.operator.PARTITION_INTERVAL }}'
  # How many partitions to keep
  PARTITION_KEEP: '{{ .Values.operator.PARTITION_KEEP }}'
  # How often to check if an old partition should be removed
  PARTITION_SYNC: '{{ .Values.operator.PARTITION_SYNC }}'
  # Whether to create a new table in the operator
  CREATE_TABLE: '{{ .Values.operator.CREATE_TABLE }}'
  # Record data inserted on Operator
  UPDAE_TSD_INFO: '{{ .Values.operator.UPDAE_TSD_INFO }}'
  # Archive data coming in
  ARCHIVE: '{{ .Values.operator.ARCHIVE }}'
  # Compress JSON and SQL file(s) backup
  COMPRESS_FILE: '{{ .Values.operator.COMPRESS_FILE }}'
  # How many threads to use in the operator process
  OPERATOR_THREADS: '{{ .Values.operator.OPERATOR_THREADS }}'

  # -- Publisher --
  # Location of logical database name within file name
  DBMS_FILE_LOCATION: '{{ .Values.publisher.DBMS_FILE_LOCATION }}'
  # Location of table name within file name
  TABLE_FILE_LOCATION: '{{ .Values.publisher.TABLE_FILE_LOCATION }}'
  # Compress JSON and SQL file(s) backup
  PUBLISHER_COMPRESS_FILE: '{{ .Values.publisher.PUBLISHER_COMPRESS_FILE }}'

  #-- Authentication --

  #-- MQTT --
  # Whether to enable the default MQTT process
  ENABLE_MQTT: '{{ .Values.mqtt.ENABLE_MQTT }}'
  # Whether to enable MQTT logging process
  MQTT_LOG: '{{ .Values.mqtt.MQTT_LOG }}'
  # IP address of MQTT broker
  MQTT_BROKER: '{{ .Values.mqtt.MQTT_BROKER }}'
  # Port associated with MQTT broker
  MQTT_PORT: '{{ .Values.mqtt.MQTT_PORT }}'
  # User associated with MQTT broker
  MQTT_USER: '{{ .Values.mqtt.MQTT_USER }}'
  # Password associated with MQTT user
  MQTT_PASSWD: '{{ .Values.mqtt.MQTT_PASSWD }}'
  # Topic to get data for
  MQTT_TOPIC: '{{ .Values.mqtt.MQTT_TOPIC }}'
  # Logical database name
  MQTT_DBMS: '{{ .Values.mqtt.MQTT_DBMS }}'
  # Table where to store data
  MQTT_TABLE: '{{ .Values.mqtt.MQTT_TABLE }}'
  # Timestamp column name
  MQTT_TIMESTAMP_COLUMN: '{{ .Values.mqtt.MQTT_TIMESTAMP_COLUMN }}'
  # Value column name
  MQTT_VALUE_COLUMN: '{{ .Values.mqtt.MQTT_VALUE_COLUMN }}'
  # Column value type
  MQTT_VALUE_COLUMN_TYPE: '{{ .Values.mqtt.MQTT_VALUE_COLUMN_TYPE }}'

  #-- Advanced Settings --
  # Whether to automatically run a local (or personalized) script at the end of the process
  {{ if .Values.advanced_settings.DEPLOY_LOCAL_SCRIPT }}
    DEPLOY_LOCAL_SCRIPT: '{{ .Values.advanced_settings.DEPLOY_LOCAL_SCRIPT }}'
  {{ end }}
  # Number of TCP threads
  TCP_THREAD_POOL: '{{ .Values.advanced_settings.TCP_THREAD_POOL }}'

  # Number of parallel queries
  QUERY_POOL: '{{ .Values.advanced_settings.QUERY_POOL }}'
  # When data comes in write to database immidiately, as opposed to waiting for a full buffer
  WRITE_IMMEDIATE: '{{ .Values.advanced_settings.WRITE_IMMEDIATE }}'
  # If buffer is not full, how long to wait until pushing data through
  THRESHOLD_TIME: '{{ .Values.advanced_settings.THRESHOLD_TIME }}'
  # Buffer size to reach, at which point data is pushed through
  THRESHOLD_VOLUME: '{{ .Values.advanced_settings.THRESHOLD_VOLUME }}'


